{\rtf1\ansi\ansicpg1252\deff0{\fonttbl{\f0\fnil\fcharset0 Courier New;}{\f1\fnil\fcharset2 Symbol;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\lang1033\b\f0\fs28 Chapter 2 - Acme Car Rental Example\fs22\par
\b0\par
1. Show Car Rental app - branch Chapter2-01-NoAOP\par
2. Show with logging (not AOP) \par
   \tab branch: \b Chapter2-02-Logging-NoAOP\par
\b0    a. console logging\par
   b. manual defensive programming checks on Accrue and Redeem\par
   c. Transactions and retries\par
      - what if more exceptions occur outside of the inner try/catch?\par
\tab d. Handling general exceptions\par
\par
3. Show refactored code (still no AOP) \par
   \tab branch: \b Chapter2-03-NoAOP-RefactoringTheMess\b0\par
   - Pass responsibility to dependencies in services\par
   - Constructor getting kinda cluttered\par
\par
4. More refactoring (Still no AOP, but cleaning up)\par
     branch: \b Chapter2-04-NoAOP-MoreRefactoring\par
\b0\tab - combining transaction and exception handling managers into \par
transaction manager\par
   \tab - still difficult to make changes -- the transaction and exception manager were able to be combined, but that's not always possible.\par
   \tab - signature changes - if you remove or add a parameter, you have to remember to remove or add the defensive programming. Same goes for parameter name changes.\par
   \tab - even with dependencies, what if someone adds a method and forgets to call the transaction manager?\par
\par
5. Refactor with AOP\par
\tab branch: \b Chapter2-05-RefactorWithAOP\par
\b0    \tab - Start with Logging\par
\pard\ri-1800\tx8640      new class 'LoggingAspect' inheriting from OnMethodBoundaryAspect\par
\pard    \tab - add this aspect to Accrue and Redeem\par
   \tab - tag: \b Chapter2-05-BasicMethodLoggingWithAOP\par
\b0        - doesn't give a lot of detail about the arguments\par
   \tab - tag: \b Chapter2-05-BetterMethodLoggingWithAOP\b0\par
       - enhanced the entities with loggable information so\par
\tab     LoggingAspect can log arbitrary arguments\par
   \tab - tag: \b Chapter2-06-AddDefensiveProgrammingAspect\par
\b0    \tab\tab - added aspect for Defensive Programming to check for null arguments\par
\tab\par
\tab - Aspect for Transactions and Retries\par
\tab\tab - Uses MethodInterceptionAspect instead of OnMethodBoundaryAspect\par
\tab\tab   - this runs code \b instead \b0 of the method that's being intercepted\par
\tab\tab   - uses args.Proceed() to call the intercepted method\par
\tab - tag: \b Chapter2-07-AddTransactionManagementAspect\b0\par
\tab\par
\tab - Aspect for Exception Handling\par
\tab - tag: \b Chapter2-08-AddExceptionAspect\b0\par
\par
\tab Now, each cross-cutting concern has its own class, and the \tab service code \b only\b0  contain business logic.\par
\par
\b\par
\par
\b0\fs28 Chapter 3 - Method Interception in Castle DynamicProxy and PostSharp\fs22\par
\tab - Aspects that run code in place of another method whenever that method is called.\par
\tab - used for logging, validation, error handling, etc.\par
\par
\tab branch: \b Chapter3-01-PostSharpMethodInterception\b0\par
\tab New Project: TweetPostSharp\par
\tab - Aspect inherits from MethodInterceptionAspect\par
\tab - in OnInvoke(), args.Proceed() calls the intercepted method.\par
\tab - PostSharp works right after compilation\par
\par
\tab branch: \b Chapter3-02-CastleDynamicProxyMethodInterception\b0\par
\tab New Project: TweetDynamicProxy\par
\tab - Aspect implements IInterceptor, which has one method, Intercept\par
\tab - DynamicProxy works during runtime\par
\tab - Interceptors applied to entire object. It can still target entire methods using IInterceptorSelector though.\par
\tab   1. Create a ProxyGenerator\par
\tab   2. Using ProxyGenerator to apply the interceptor.\par
\b\tab - tag: Chapter3-02-PostSharpMethodInterception\par
\b0\par
\b branch: Chapter3-03-DynamicProxyTransactionAspect\par
\b0\tab - Create service that takes an invoice and does several DB operations\b\par
\b0\tab - 3 methods: Save that always succeeds; Save that succeeds after a retry; Save that always fails\b\par
\b0\tab - Using .NET's Transaction Scope, there is no explicit Rollback; there is only Dispose(). If you dispose scope before doing a Complete(), it will be rolled back. So we add a call to Dispose in the transaction interceptor.\par
\b\tab - tag: Chapter3-04-DynamicProxyTransactionsInitial\par
\b0\par
\tab - To do retries, we'll put looping in the Intercept call.\par
\tab - We put retries as a constructor parameter in the aspect class.\par
\tab - We also log the method name when retrying using invocation.Method.Name\par
\b\tab - tag: Chapter3-05-DynamicProxyTransactionsBetter\b0\par
\par
\tab .NET Threading Example\par
\b\tab branch: Chapter3-04-UIThreadsInterception\par
\b0\tab - project: UIThreadingExample\par
\tab Long-running tasks in Win Forms make the UI hang unless you dispatch them to a separate thread. (can demo, but not in Debug mode)\par
\tab Our example is updating a UI control from a worker thread, which is a bad idea. Only the UI thread should do this.\par
\tab\par
\tab We should check to see if we're running on the UI thread.\par
\b\tab - tag: Chapter3-06-UIThreading-UpdateFromWrongThread\tab\b0\par
\tab\par
\tab To do this correctly, use Invoke() and InvokeRequired()\par
\b\tab - tag: Chapter3-07-UIThreading-InvokeCorrectly\b0\par
\tab\par
\tab Now our business logic is polluted with code that has to care about whether it's a worker thread or the UI thread. And the fact that the button's click handler has to create Threads is cluttered.\par
\par
\tab We can make aspects in PostSharp so we don't keep having to use InvokeRequired(). Wouldn't it be cool if we could decorate methods with [WorkerThread] or [UIThread] and have that do the hard work?\par
\par
\tab Interceptors: WorkerThread, UIThread\par
\tab\par
\tab We pass the work of creating a thread to the WorkerThread, and the UIThread aspect can do the checking of which thread it's being invoked from.\par
\b\tab - tag: Chapter3-08-UIThreading-ThreadingAspectsAdded\par
\b0\par
\par
\b\fs28 Chapter 4 - Method Interception vs Method Bounding\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\b0\fs24 1 - Boundary Aspects\par
\b{\pntext\f1\'B7\tab}branch: Chapter4-01-BoundaryThreadsExample\par
{\pntext\f1\'B7\tab}Project: Ch4-BaseballStatsPostSharp\par
\b0\fs22{\pntext\f1\'B7\tab}Running aspects at the boundaries of methods\fs24\par
\fs22{\pntext\f1\'B7\tab}In even the simplest case, there are boundaries between every method call we can exploit with our mastery of Aspects.\fs24\par
\fs22{\pntext\f1\'B7\tab}tag: Chapter4-01-BattingAverageNoAOP\fs24\par
\fs22{\pntext\f1\'B7\tab}Adding basic MethodBoundary Aspect\fs24\par
{\pntext\f1\'B7\tab}When to use Method Boundary Aspects and when to use Method Interception?\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li1080 Method Interception allows shared scope across different handlers (as otherwise you'd have a separate boundary method/aspect for On Success, On Exception, On Exit, while these all are handled together in a Method Interception method/aspect)\par
{\pntext\f1\'B7\tab}You could use a field on the Aspect class to share state across methods, but they are statically scoped, so only one Aspect class is created for all instances of a class that uses it.\par
{\pntext\f1\'B7\tab}It's possible to use a property of the MethodExecutionArgs class (MethodExecutionTag) to share state, but it is fairly limited and not the most convenient. If you need to share a lot of state, you may need a whole class to store in the MethodExecutionTag.\par
{\pntext\f1\'B7\tab}But! Method Boundary Aspects can be a lot clearer. You don't need the try/catch/finally, or the args.Proceed() call, as each of these can be handled by a separate Method Boundary Aspect.\par
{\pntext\f1\'B7\tab}\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\fs22 tag: Chapter4-02-BattingAverageBasicAOP\fs24\par
\pard\li360\par
\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\b 2 - ASP.NET HTTP Module bounding\par
{\pntext\f1\'B7\tab}branch: Chapter4-03-ASPNETModules\par
{\pntext\f1\'B7\tab}Project: Ch4-AspNetHttpModuleDemo\par
{\pntext\f1\'B7\tab}\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\b0 Http Modules allow you to put code at the boundaries of ASP.Net pages.\par
{\pntext\f1\'B7\tab}Have to configure them in web.config\par
{\pntext\f1\'B7\tab}Once you set up event handlers in your module for BeginRequest and EndRequest, you can inject your own code at these seams.\par
\b{\pntext\f1\'B7\tab}tag: Chapter4-03-AspNetBasicModule\b0\par
\pard\li360\par
\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720 Real-World Example: Detecting Mobile Users\par
{\pntext\f1\'B7\tab}Offer a link to your mobile app if they're on a mobile device. Everyone loves that, right???\par
\pard\li360\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\b Project: Ch4-MobileBrowserAspNet\par
\b0{\pntext\f1\'B7\tab}When a user requests a page from a mobile device, present them with a splash page that asks if they want to download the app.\b\par
\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\b0 We have to make sure that the splash page that is displayed when users request a page doesn't get the call to itself intercepted, and that when they're redirected to the original requested page, they don't get the splash page again.\par
{\pntext\f1\'B7\tab}And to make sure they don't get the splash page before EVERY page. Show it only once (based on Cookie). Code in NoThanks click event handler and the HttpModule we created.\par
\pard\li360\par
\par
\par
\par
\pard\par
\par
\b\fs22\par
\par
\par
\tab\b0\par
\par
\b\par
\fs28 Chapter 5 - Location Interception\par
\fs22\par
\par
\par
\par
\fs28 Chapter 6 - Unit Testing of Aspects and Testing How They Are Applied (Using NUnit)\par
\b0\fs22\par
\par
\par
}
 